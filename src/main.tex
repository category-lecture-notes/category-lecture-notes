\documentclass[a4paper]{article}
\usepackage{fontspec}
\usepackage{geometry}
\usepackage{microtype}
\usepackage{enumitem}
\usepackage{bbold}
\usepackage{tikz-cd}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{csquotes}
\usepackage{xparse}
%\usepackage{hyperref}

\ExplSyntaxOn

\setlength { \parindent } { 0em }
\setlength { \parskip } { .5em }

\setlist
  {
  %  noitemsep,
  }

\NewDocumentCommand \Z {}
  { \ensuremath { \mathbb { Z } } }

\NewDocumentCommand \Q {}
  { \ensuremath { \mathbb { Q } } }

% https://tex.stackexchange.com/questions/4624
\NewDocumentCommand \quotient {mm}
  {
    \ensuremath
      {
        \left .
        \raisebox { .2em } { \( #1 \) }
        \middle /
        \raisebox { -.2em } { \( #2 \) }
        \right .
      }
  }

\NewDocumentCommand \one {o}
  {
    \ensuremath
      {
        \mathrm { 1 }
        \IfNoValueF {#1}
          { \sb {#1} }
      }
  }

\NewDocumentCommand \category {m}
  { \ensuremath { \mathbf {#1} } }

\NewDocumentCommand \Grp {}
  { \category { Grp } }

\NewDocumentCommand \Set {}
  { \category { Set } }

\NewDocumentCommand \Top {}
  { \category { Top } }

\NewDocumentCommand \Ring {}
  { \category { Ring } }

\NewDocumentCommand \Groupoid {}
  { \category { Ring } }

\NewDocumentCommand \Cat {}
  { \category { Cat } }

\NewDocumentCommand \One {}
  { \category { 1 } }

\NewDocumentCommand \Two {}
  { \category { 2 } }

\NewDocumentCommand \C {}
  { \ensuremath { \mathcal { C } } }

\NewDocumentCommand \D {}
  { \ensuremath { \mathcal { D } } }

\NewDocumentCommand \pset {}
  { \ensuremath { \mathcal { P } } }

\NewDocumentCommand \op {m}
  { \ensuremath { {#1} ^ \text { op } } }

\NewDocumentCommand \Cop {}
  { \op { \C {} } }

\DeclareMathOperator \Hom { Hom }

\NewDocumentCommand \defeq {}
  { \coloneqq }

\NewDocumentCommand \ie {}
  { \emph { i.e. } }

\theoremstyle { remark }
\newtheorem { remark } { Remark }
\newtheorem { warning } { Warning }

\theoremstyle { definition }
\newtheorem { definition } { Definition }
\newtheorem { example } { Example }
\newtheorem { property } { Property }

\theoremstyle { plain }
\newtheorem { lemma } { Lemma }
\newtheorem { theorem } { Theorem }

\DeclarePairedDelimiterX { \set } [1] \{ \}
  {
    \DeclareDocumentCommand \given {}
      {
        \nonscript \: \delimsize \vert
        \allowbreak
        \nonscript \:
        \mathopen {}
      }
    #1
  }

\ExplSyntaxOff

\title{catégorie poly}
\author{Serge Lechenne \and Lucas Tabary Maujean \and Arthur Adjedj \and Balthazar Patchiatchvily \and Vincent Lafeychine}

\begin{document}

\maketitle

\section{Introduction}

I'll start by a question: What does \enquote{same} mean?

Intuitively, we feel that \( (\Z, <) \) and \( (\Q, <) \) are different as ordered structures, that \( \quotient{\Z}{4\Z} \) and \( \quotient{\Z}{2\Z} \times \quotient{\Z}{2\Z} \) are two \enquote{different} groups:
\begin{itemize}
  \item for the former example, \( \Q \) is a dense order, and \( \Z \) is not,
  \item for the latter one, \( \quotient{\Z}{4\Z} \) is cyclic, and the other is not.
\end{itemize}

Clearly, in the sense of two object being the \enquote{same} (or not), there is some kind of interactions between elements that creates different behaviours.
One would say that there is no \enquote{structure preserving bijection}, for the first one, no bijective order embedding, for the second, no group isomorphism.
However, defining \enquote{structure} by \enquote{I preserve structure} is not a satisfying approach.

Yet, in the two examples, we were able to say those \enquote{structures} were different by simply finding a property that one possesses and the other don't.
So, instead of trying to state what this general \enquote{structure} thing is, let's just look at how it behaves!
That this \enquote{structure} is, to put it mildly, just relations that the elements have one with another.
That what really matters is not to characterise interactions, but to characterise the definition of interaction, by grouping objects and those relations in a new object.
So, we just simply consider those objects, with, between two objets, a sort of \enquote{relation} that would describe the interactions of one between another.

We therefore give it a name: a \emph{category}.

\section{Definition of a category, and internal properties}

\begin{definition}[Category]
A category is the following things:
\begin{itemize}
  \item A collection of objects,
  \item A collection of morphism, or arrows, such that each morphism \( f \) has a \emph{domain} and \emph{codomain}.
    A morphism \( f \) of domain \( x \) and codomain \( y \) will be written \( f \colon x \to y \).
    We also ask the following properties:
    \begin{itemize}
        \item for \( f \colon x \to y \) and \( g \colon y \to z \), there is a morphism called \( fg \colon x \to z \).
          Two such morphism \( f \) and \( g \) will be called \emph{composable},
        \item for each element \( x \) there is a morphism \( \one[x] \colon x \to x \),
        \item for \( f \), \( g \) and \( h \) composable, we have \( f(gh) = (fg)h \),
        \item for \( f \colon x \to y \), we have \( f \one[x] = f = \one[y] f \).
    \end{itemize}
\end{itemize}
\end{definition}

\begin{example}
Some categories are already known:
\begin{itemize}
  \item \( \Set \), the category of set, and arrows as functions,
  \item \( \Grp \), the category of Groups, and arrows as group morphism,
  \item \( \Ring \), the category of rings, and arrows as ring morphism,
  \item \( \Top \), the category of topological spaces and continous functions.
\end{itemize}

But a category can be just a reformulation of a known object: 
\begin{itemize}
  \item any (pre)ordered set \( (P, \leq) \) is a category, named \( P \) with objects the element of \( P \), and, between \( (x, y) \), a unique \( f \colon x \to y \) iff \( x \leq y \),
  \item any graph \( (V, E) \) gives rise to a category by considering \( V \) as the collection of elements, and having exactly one arrow \( f \colon x \to y \) iff \( y \) is reachable from \( x \).
\end{itemize}
\end{example}

It is important to note that the composition \( gf \) is comprised in the definition of a category either implicitely (like the first examples), or explicitely with the past two examples.

So, a lot of objects can be naturally described as a category, their internal structure being discribed by arrows and compositions of such arrows.

Category admit a natural, \enquote{graph like} representation: element are points, and morphism are arrows between points.
We usually omit the composition arrows and the \( \one[x] \) arrows.
The following category, for example, is named \( \One \):

\begin{center}
\begin{tikzcd}
  \arrow[loop left]{l}{\one[x]} x.
\end{tikzcd}
\end{center}

Now that we defined the concept, let's give some terminology and present classical constructions.

\begin{definition}[\( \Cop \)]
Let \( \C \) be a category.

We call \( \Cop \) the category with same object, and for arrows, a morphism \( \op{f} \colon y \to x \) for each morphism \( f \colon x \to y \).
\end{definition}

\begin{example}
It is not outright clear to why this construction is important, but it serves to naturally express some concepts, as we will see in, for example: 
Given a poset \( \C \defeq (P, \leq) \), \( \Cop \) is \( (P, \geq) \).
\end{example}

Our initial objective was to give a general sense to what \enquote{same} means: what would be an \enquote{isomorphism} in a category.
We'll now introduce terminology on arrows.

\begin{definition}[Monomorphism, epimorphism and isomorphism]
Let \( \C \) be a category.

We say that \( f \colon x \to y \) is:
\begin{itemize}
  \item a monomorphism if, for all \( a, b \colon y \to z \), \( fa = fb \implies a = b \),
  \item an epimorphism if \( \op{f} \) is a monomorphism, \ie{} for all \( a, b \colon z \to x \), \( af = bf \implies a = b \),
  \item an isomorphism if there exists \( g \colon y \to x \) such that \( gf = \one[x] \) and \( fg = \one[y] \),
    If there exists such an \( f \), we will say that \( x \) and \( y \) are \emph{isomorphic}, and write it \( x \cong y \).
\end{itemize}
\end{definition}

It is clear that an isomorphism is a monomorphism and an epimorphism, but the contrary is (true in \( \Set \)) but NOT true in general: take \( f \colon x \to y \) in the following category \Two:

\begin{center}
\begin{tikzcd}
  x \arrow[loop left, "1_x"] \arrow[r] \arrow[r, "f"]
  & y. \arrow[loop right, "1_y"] % TODO
\end{tikzcd}
\end{center}

We say that a category \( \C \) that only contains isomorphisms is a \emph{groupoid}.

A special kind of groupoid is a groupoid with only one element, that we will call a… group.
Indeed, given \( G \in \Grp \), we consider the category comprised of only one element \( \Delta \), and, for each \( x \in G \), an arrow \( x \colon \Delta \to \Delta \), composition of arrow is defined by composition of element, and \( e \) is the arrow \( \one[\Delta] \).

We'll explore this construction more in detail in the next chapter.

Indeed, isomorphism are exactly what we wanted to define structure: indeed, two objects \( x \) and \( y \) are said \emph{isomorphic} if there is an isomorphism between them: it is the category \emph{itself} that defines the notion of structure by defining the isomorphism, as opposite to the \enquote{traditionnal} approach, that would define a specific kind of structure (like groups, vector spaces) and then define isomorphism as \enquote{bijective maps preserving the structure.}

\begin{definition}[Hom-set, small and locally small categories]
Let \( \C \) be a category. For all \( x, y \in \C \), we name \( \C(x,y) \) (also written as \( \Hom_\C(x,y) \) the collection of arrows between \( x \) and \( y \).

We say that a category is \emph{small} if it has only a set worth of object.

We say that a category is \emph{locally small} if, for all \( x, y \in \C \), \( \C(x, y) \) is a set.
\end{definition}

As for now, the importance of smallness and local smallness don't seem relevant, but the importance of local smallness will be highlithed in the next chapter.

\section{The end?}

The picture seems to be somehow \enquote{complete}: we described what \enquote{same} means, we gave a general frame of work to study \enquote{structures}, and gave some terminology.
We could simply transpose all of our results from various fields of mathematics in this new language, and everything will be great.

\begin{itemize}
\item One one hand, we have the categories themselves in which inside of them we describes structure.
\item On other hand, we have a general notion of category that serves as a framework.
\end{itemize}

However, there is one \enquote{little} question that remains to be answered, and that is on the back of our minds since the definition of \( \Cop \): if we flip twice the arrows, we end up with the same category: \( \op{(\Cop)} = \C \).

The contruction of \( \Cop \) is taking a category \( \C \), keeping the same elements, and, for just every arrow \( f \colon x \to y \), flipping it around.
Moreover, we defined the composition such that \( \op{(gf)} \) is \( \op{f} \op{g} \), and, of course $\op{\one[x]} = \one[x]$.

So, the \enquote{thing}, that we will name \( \op{(\_)} \) is sending a category \( \C \) to \( \Cop \) is, \enquote{composed} with itself, the \enquote{identity over categories}.
Moreover, it preserves the composition and the indentity arrows.
So, \( \op{(\_)} \) is a sort of \enquote{morphism of category}.

Which would imply that categories \emph{themselves} are a structure?
But what is a morphism of category then?

\section{Functors}

The precedent observation motivates the following definition, absolutely central in category theory, becauses it allow us to compare how do categories themselves behave one respectively to another.

\begin{definition}[Covariant functors]
Let \( \C \) and \( \D \) be categories.

A covariant functor is two things:
\begin{itemize}
  \item for each objet \( c \in \C \), an object \( F c \in \D \),
  \item for each arrow \( f \colon x \to y \), an arrow \( F f \colon F x \to F y \).
\end{itemize}

And, the arrows $Ff$ needs to satisfy the two following conditions:
\begin{itemize}
  \item for any composable $f, g$, we have $F(gf) = (Fg) (Ff)$,
  \item for all $x \in \mathcal{C}$, we have $F(1_{x}) = 1_{F(x)}$.
\end{itemize}
\end{definition}

\begin{definition}[\( \Cat \)]
\( \Cat \) is the category formed with object the categories and arrows the functors between categories.
In addition to that, one can now verify that \( \op{(\_)} \colon \Cat \to \Cat \) is indeed a functor.
\end{definition}

\begin{remark}
One can say that this may lead to a foundation problem, because we would have \( \Cat \in \Cat \), which would lead to a Russel-like paradox.
However, this text is only an introduction, so I can't bring any satisfactory response to this observation.
\end{remark}

\begin{example}[Groups as one object groupoids]
Given a group \( G \), one can construct a one object groupoid \( B G \), as explained previously.

We now consider \( \Groupoid \), the category formed by groupoids and functors.

Given two groups \( G \), \( G' \) and \( \phi \colon G \to G' \) a group morphism, we pose \( B \phi \colon B G \to B G' \) the functor that sends the element \( \Delta \) of \( B G \) to the element \( \Delta' \) of \( B G' \), and an arrow \( x \colon \Delta \to \Delta \) to \( \phi(x) \colon \Delta' \to \Delta' \).
Because \( \phi \) is a group morphism, it is clear (but verify!) that \( B G \) is a functor.

\textit{In fine}, we have that \( B \colon \Grp \to \Groupoid \) is a functor.

With this example in mind, we see that it is important to view functor and morphism in a unified way, as functor are just morphism of \( \Cat \).
Now, let's give some more interesting example
\end{example}

\begin{example}[Some examples of functors to know] \label{ex:some-functors}
\leavevmode % FIXME (à cause des multiples exemples dans un example)

\begin{itemize}
  \item The functor \( U \colon \Grp \to \Set \) that sends a group to its base set (and group morphism to the underlining functions).
    This functor is called a \enquote{forgetful} functor, because it \enquote{forgets} the structure.
  \item Given \( \C \) a locally small category, and \( x \in \C \), we name \( \C(x, \_) \colon \C \to \Set \) the functor sending \( y \) to the \emph{set} (because \( \C \) is locally small) of arrows between \( x \) and \( y \), and \( f \colon y \to z \) to the function
    \begin{align*}
      f^{*} \colon \C(x,y) &\to \C(x,y) \\
                    g &\mapsto fg.
    \end{align*}
  \item The powerset functor \( \pset \colon \Set \to \Set \) that sends \( X \) to \( \pset(X) \) and \( f \) to the mapping between powersets: \( \pset(f)(X) \defeq f(X) \).
\end{itemize}

From the power set \( \pset \), we can define an other \enquote{functor} like object: it sends \( X \) to \( \pset(X) \) but from an arrow \( f \colon X \to Y \) takes it to the arrow \( f^{-1} \colon \pset(Y) \to \pset(X) \).
This satisfies the definition of a functor, only not of \( \Set \to \Set \), but of \( \op{\Set} \to \Set \), which motivates to consider another kind of functors, to describes this \enquote{arrow inversion} functoriality.
\end{example}
 
\begin{definition}[Contravariant functor]
Given \( \C \) and \( \D \) two categories, a contravariant functor is a functor \( F \colon \op{\C} \to \D \).

This means that it is two things: 
\begin{itemize}
  \item for each objet \( c \in \C \), an object \( F c \in \D \),
  \item for each arrow \( f \colon y \to x \), an arrow \( F f \colon F x \to F y \).
\end{itemize}

And, the arrows \( F f \) need to satisfy the two following conditions:
\begin{itemize}
  \item for any composable \( f \) and \( g \), we have \( F (gf) = (F g) (F f) \),
  \item for all \( x \in \C \), we have \( F(\one[x]) = \one[F(x)] \).
\end{itemize}
\end{definition}

\begin{lemma}[Functor preserves isomorphism]
Let \( F \colon \C \to \D \) be a functor, and \( f \) be a morphism in \( \C \) we then have
\[
  \text{\( f \) isomorphism} \implies \text{\( F f \) isomorphism}.
\]

\begin{proof}
Let \( g \) be the inverse to \( f \), then it is easy to verify that \( F g \) is an inverse to \( F f \).
\end{proof}
\end{lemma}

\begin{warning}
\( F \C \) with arrows \( F f \)'s is not a subcategory of \( \D \).

\begin{proof}
Take the following categories:

\begin{center}
\begin{tikzcd}
  A \arrow[r, "f"] & B \\
  C \arrow[r, "g"] & D.
\end{tikzcd} 
\end{center}

And \( \mathbb{3} \):
\begin{tikzcd}
  0 \arrow[r, "u"] & 1 \arrow[r, "v"] & 2.
\end{tikzcd}

We consider the functor \( F \) that sends \( A \) to \( 0 \), \( B \) to \( 1 \), \( C \) to \( 1 \), \( D \) to \( 2 \), and \( f \) to \( u \), \( g \) to \( v \).

However, \( F f \) and \( F g \) are composable in \( \mathbb{3} \), but their composition does not belong to \( F \).
\end{proof}
\end{warning}

Analogous sets/groups/… and bijections/isomorphism/…, we can try to define the fact that two categories have the same property by finding an \enquote{isofunctor} between them.
Unlike functions however, functors not only transforms the element but also the arrows: we therefore have to account for a sort of surjectivity and injectivty on arrows also.
This give rises to the following definitions:

\begin{definition}[Fullness and faithfullness]

Let \( \C \) and \( \D \) be locally small categories \( F \colon \C \to \D \) be a functor.

We say that \( F \) is:
\begin{itemize}
\item \emph{full} if for all \( x, y \in \C \) the function from \( \C(x, y) \) to \( \D(F x, F y) \) is surjective,
\item \emph{faithful} if for all \( x, y \in \C \) the function from \( \C(x, y) \) to \( \D(F x, F y) \) is injective,
\item \emph{essentially surjective} if for all \( y \in \D \), there exists \( x \) s.t. \( F x \cong y \).
\end{itemize}

A full functor is a functor that covers all the possible maps, and a faithfull functor is a functor that you can trust on the maps it covers (hence the names).
However, this conditions are \emph{local}: given \( f \colon x \to y \) and \( g \colon a \to b \), with \( a \neq b \), \( F f = F g \) does not contradicts faithfulness.

In the following, we will say that a functor \( F \) is \emph{fully faithful} if it is both faitful and full.

\end{definition}

We also have this useful result:

\begin{property}[Fully faithful functors reflect isomorphism]
Let \( F \colon \C \to \D \), then for all \( f \colon x \to y \), we have
\[
  \text{\( F f \) isomorphism} \implies \text{\( f \) isomorphism}.
\]
\end{property}

However, our picture on category theory is not yet complete: what do \enquote{same} mean on functor \emph{one with another}?
The first idea (in this categorical setting) would be to make a category where functors are \emph{object}, then what is an arrow \( \alpha \colon F \to G \)?

\section{Natural transformations and representability}

\begin{definition}[Natural transformation]
Let \( F, G \colon \C \to \D \) two functors.

A \emph{natural transformation} \( \alpha \) between \( F \) and \( G \) is a family of arrows \( (\alpha_c \colon F c \to G c)_{c \in \C} \) such that for all \( x, y \in \C \) and \( f \in \C(x, y) \) the following diagram commutes (\ie{} \( G f \alpha_x = \alpha_d F f \)):

\begin{center}
\begin{tikzcd}[column sep=huge]
A \arrow[r, "\alpha_x"] \arrow[d, "Ff" ']
& B \arrow[d, "Gf"]\\
C  \arrow[r, "\alpha_d" ']
&  D.
\end{tikzcd}
\end{center}

A natural transformation will be written \( \alpha \colon F \Rightarrow G \), and will be written diagrammatically as:

\begin{center}
\begin{tikzcd}[column sep=huge]
    \mathcal{C}
     \arrow[r, bend left=65, "F"{name=F}]
     \arrow[r, bend right=65, "H"{name=H, swap}]
     \arrow[from=F.south-|H,to=H,Rightarrow,shorten=2pt,"\alpha"] &
   \mathcal{D}.
\end{tikzcd}
\end{center}

\end{definition}

To put it simply, natural transformation is bridge between the arrows $Ff$ and $Gf$, allowing you to go from one functor to another.

We also call a \emph{natural ismorphism} a natural transformation \( \alpha \colon F \to G \) in which all \( \alpha_c \) are isomorphisms.
Given a functor \( F \), a particular example of natural isomorphism is \( \one[F] \colon F \Rightarrow F \), consisting of the family \( (\one[F_c])_{c \in \C} \).

\( \one[F] \) is a natural transformation.

Moreover, given \( \alpha \colon F \Rightarrow G \) and \( \beta \colon G \Rightarrow H \), we write \( \beta * \alpha \colon F \Rightarrow H \) the natural transformation \( (\beta_c \alpha_c \colon Fc \to Hc)_{c \in \mathcal{C}} \).
It is a good exercice to verify that indeed, it is a natural transformation.

This composition is called the \emph{vertical} composition because diagrammatically, it looks like this: 

\begin{center}
\begin{tikzcd}[column sep=huge]
  \mathcal{C}
  \arrow[r, bend left=65, "F"{name=F}]
  \arrow[r, "G"{inner sep=0,fill=white,anchor=center,name=G}]
  \arrow[r, bend right=65, "H"{name=H, swap}]
  \arrow[from=F.south-|G,to=G,Rightarrow,shorten=2pt,"\alpha"] 
  \arrow[from=G,to=H.north-|G,Rightarrow,shorten=2pt,"\beta"] &
  \mathcal{D}
\end{tikzcd}
= 
\begin{tikzcd}[column sep=huge]
  \mathcal{C}
  \arrow[r, bend left=65, "F"{name=F}]
  \arrow[r, bend right=65, "H"{name=H, swap}]
  \arrow[from=F.south-|G,to=H,Rightarrow,shorten=2pt,"\beta * \alpha"] &
  \mathcal{D}.
\end{tikzcd}
\end{center}

Those two considerations amounts to considering a new kind of categories.

\begin{definition}[Power category]
Let \( \C \) and \( \D \) be two categories.

We name \emph{power category}, written \( \D^\C \), the category:
\begin{itemize}
  \item with objects functors between \( \C \) and \( \D \),
  \item and arrows natural transformations (composition being the vertical composition, identity being \( \one[F] \)).
\end{itemize}
\end{definition}

\noindent With this definition, we note that a natural isomorphism is an isomorphism in \( \D^\C \) (verify it! it is not hard but serves to familiarize with manipulation of natural transformation and diagrammatic reasonning).

Let's hold on a minute and go back to our favorite category, \( \Set \).

In \( \Set \), to study two sets \( X \) and \( Y \), we can find a pair of inverse between \( X \) and \( Y \).
Or, instead, we can find a surjective and injective function from \( X \) to \( Y \) or \( Y \) to \( X \).
This idea can be translated as a general one inside of category theory with the following definition and theorem:

\begin{definition}[Equivalence of categories]
Let \( \C \) and \( \D \) be categories, and \( F \colon \C \to \D \) and \( G \colon \D \to \C \) be functors.

We say that \( F \) and \( G \) realizes an \emph{equivalence of categories} if there exist two natural isomorphism \( \eta \colon G F \Rightarrow \one[\C] \) and \( \epsilon \colon F G \Rightarrow \one[\D] \).

We write an equivalence of category \( \C \cong \D \).
\end{definition}

This notion of equivalence demonstrate an important point:
because functors are not functions, we still need to account for their effects on arrows, and \( \eta \) and \( \epsilon \) are here to rule out this problem, and essentially saying (give it a thought) that their effects on hom-sets also cancel each others, up to isomorphism, and that, indeed, the two categories \( \C \) and \( \D \) behave in the same manner.
In the same way it is hard to find the inverse of a function, it is hard to find both \( G \), \( \epsilon \) and \( \eta \).
We therefore introduce this powerful theorem:

\begin{theorem}
Let \( \C \), \( D \) be locally small categories, and \( F \colon \C \to \D \).

The following are equivalent (assuming the axiom of choice): 
\begin{itemize}
  \item \( F \) is fully faithful and essentially surjective,
  \item there exists \( G \colon \D \to \C \) such that \( F \) and \( G \) realizes an equivalence \( \C \cong \D \).
\end{itemize}

\begin{proof}
A natural isomorphism \( \alpha \colon F \implies G \) can be reframed as a conjugation relation: \( \forall f \colon x \to y, F f = \alpha^{-1}_y G f \alpha_x \).
\end{proof}
\end{theorem}

This means that, to study a functor \( F \), one can study an other functor \( G \) naturally isomorphic to \( F \).
One of the easiest functor to study (in a practical sense) is \( \C(x, \_) \) introduced in example~\ref{ex:some-functors}.
So, it would be interesting, given a functor \( F \colon \C \to \D \) to know how it behaves relatively to all of the the functors $\C(x, \_)$ (one functor for each \( x \in \C \)): the following questions are:
\begin{itemize}
  \item Is there always an \( x \) such that \( F \cong \C(x, \_) \)?
  \item Is there at most (up to isomorphisim) one \( x \) such that \( F \cong \C(x, \_) \)?
  \item If such an \( x \) exists, what properties does it have?
\end{itemize}

This question might seem a bit \enquote{out of the hat}: we are talking here about encoding a functor \( F \colon \C \to \D \) (meaning transformations of both elements and arrows) into a \emph{single} element of \( \C \).

However, given \( U \colon \Grp \to \Set \) the forgetful functor, we have \( \Grp(\Z, \_) \cong U \).

\begin{proof}
Let's pose \( \alpha \colon \Grp(\Z, \_) \to U \).
For all groups \( G \), \( \alpha_G \) is the function:
\begin{align*}
  \Grp(\Z, G) & \to U G \\
              & \phi \mapsto \phi(0).
\end{align*}

First, \( \alpha \) is a natural transformation: indeed, given \( G \), \( H \) two groups, and \( \phi \colon G \to H \), the following diagram commutes:

\begin{center}
\begin{tikzcd}[column sep=huge]
  \Grp(\Z, G)
  \arrow[r, "\alpha_G"] \arrow[d, "\phi^{*}"'] & U G
  \arrow[d, "U\phi"] \\
  \Grp(\Z, H)
  \arrow[r, "\alpha_H" '] & U H.
\end{tikzcd}
\end{center}

Indeed, given \( f \colon \Z \to G \), we have
\[
  (U \phi) (\alpha_G(f))
  = \phi(f(0))
  = (\phi \circ f)(0)
  = \alpha_G((U\phi)(f)).
\]

And, given \( x \in G \), because \( \Z \) is generated by a single element, there is exactly one morphism \( \Z \to G \) such that \( \phi(0) = x \), wich means that every arrow \( \alpha_G \) is a bijection (an isomorphism in \( \Set \)).
\end{proof}

On the contravariant case, we instead use the (contravariant) functor \( \C(\_, w) \): a good example is the fact \( \pset \cong \Set(\set{0,1}, \_) \).

\begin{proof}
For every \( X \in \Set \), let's consider the function
\begin{align*}
  \alpha_X \colon
    \set{0, 1}^X & \to \pset(X) \\
               f & \mapsto f^{-1}(1).
\end{align*}

Let's look at a few example (give them a try yourself before looking at the proof).

In fact, \( \Set(\set{0,1}, \_) \cong \pset \).

\begin{proof}
\( \Set(\set{0,1}, \_) \implies \pset \)

be the natural transformation \( (\alpha_X \colon \set{0,1}^X \to \pset(X))_{X \in \Set} \)

Where, for each \( X \in \Set \), \( \alpha_X \) is the function  \( f \mapsto f^{-1}(1) \).

First, it is clear that, for all \( X \), \( \alpha_X \) is a bijection (therefore an isomorphism in \( \Set \)).

And, given \( f \colon X \to Y \), the following diagram commutes (\ie{} for all \( g \in \set{0,1}^X \) we have \( \set{f(x) | g(x) = 1} = TODO \):

\begin{center}
\begin{tikzcd}[column sep=huge]
  \Set(\set{0,1}, X)
  \arrow[r, "\alpha_x"]
  \arrow[d, "f^{*}"']
  & \pset(X) \arrow[d, "\pset f"] \\
  \Set(\set{0,1}, Y)
  \arrow[r, "\alpha_d" ']
  & \pset(Y)
\end{tikzcd}
\end{center}

\begin{center}
\begin{tikzcd}[column sep=huge]
  \Set(\{0, 1\}, X)
  \arrow[r, "\alpha_x"]
  \arrow[d, "\Set(\set{0,1})f" ']
  & \pset \arrow[d, "\pset f"] \\
  C \arrow[r, "\alpha_d" ']
  & D.
\end{tikzcd}
\end{center}

TODO?
\end{proof}

TODO?
\end{proof}

\end{document}
